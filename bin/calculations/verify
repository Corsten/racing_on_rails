#!/usr/bin/env bundle exec bin/rails runner

# Quick and dirty script to fetch old data and recalc competitions
require_relative "./competitions"

# rubocop:disable Rails/SkipsModelValidations
def fetch_data
  Dir.chdir("tmp/db") do
    unless File.exist?("bushtit_obra_sql")
      puts `scp nutcracker.rocketsurgeryllc.com:/mnt/bak4/daily/bushtit_obra_sql-2018-12-05.tar.gz .`
      puts `tar xf bushtit_obra_sql-2018-12-05.tar.gz`
    end
  end
end

def recreate_databases
  puts `spring stop`
  puts `mysql -u root -e 'set foreign_key_checks = 0; drop database if exists obra_development'`
  puts `mysql -u root -e 'set foreign_key_checks = 0; drop database if exists obra_test'`
  puts `bundle exec rake db:create RAILS_ENV=development`
  puts `mysql -u root obra_development < tmp/db/production.sql`
  puts `bundle exec rake db:migrate`
end

def destroy_calculations
  puts "destroy_calculations"
  ResultSource.delete_all
  Result.where(year: 2019).delete_all
  Result.where("created_at > ?", Date.new(2019)).delete_all
  Race.where("created_at > ?", Date.new(2019)).delete_all

  Calculations::V3::Calculation.all.each do |calc|
    calc.event&.destroy_races
    calc.event&.destroy!
    calc.destroy!
  end
end

def fix_source_results
  Race.where(event_id: 26_336).update_all(event_id: 26_027)
  Result.where(event_id: 26_336).update_all(event_id: 26_027)
  Race.where(event_id: 26_412).update_all(event_id: 26_357)
  Result.where(event_id: 26_412).update_all(event_id: 26_357)
  Race.where(event_id: 26_434).update_all(event_id: 26_042)
  Result.where(event_id: 26_434).update_all(event_id: 26_042)
  Race.where(event_id: 26_439).update_all(event_id: 26_116)
  Result.where(event_id: 26_439).update_all(event_id: 26_116)
  Race.where(event_id: 26_475).update_all(event_id: 26_094)
  Result.where(event_id: 26_475).update_all(event_id: 26_094)
  Race.where(event_id: 26_436).update_all(event_id: 26_089)
  Result.where(event_id: 26_436).update_all(event_id: 26_089)
  Race.where(event_id: 26_596).update_all(event_id: 26_046)
  Result.where(event_id: 26_596).update_all(event_id: 26_046)
  Race.where(event_id: 26_345).update_all(event_id: 25_760)
  Result.where(event_id: 26_345).update_all(event_id: 25_760)
  Race.where(event_id: 26_318).update_all(event_id: 25_985)
  Result.where(event_id: 26_318).update_all(event_id: 25_985)
  Race.where(event_id: 26_332).update_all(event_id: 26_122)
  Result.where(event_id: 26_332).update_all(event_id: 26_122)
  Event.where(id: 26_340).update_all(parent_id: 25_760)
  Event.where(id: 26_340).update_all(discipline: "Time Trial")
  Event.where(id: 26_343).update_all(parent_id: 25_760)
  Event.where(id: 26_443).update_all(discipline: "Mountain Bike")
  Event.where(id: 26_331).update_all(type: "SingleDayEvent")
  Event.where(id: [26_340, 26_343, 26_348]).update_all(type: "SingleDayEvent")
end

def create_calculations(competitions)
  competitions.each do |key, competition|
    next if Calculations::V3::Calculation.where(key: key).exists?

    competition[:rules][:key] = key
    calculation = create_calculation(competition[:event_id], competition[:rules], competition[:name])

    competition[:categories]&.each do |category_definition|
      category = Category.find_or_create_by(name: category_definition[:name])
      calculation_category = Calculations::V3::Category.new(
        category: category,
        maximum_events: category_definition[:maximum_events],
        reject: category_definition[:reject] || false
      )
      calculation.calculation_categories << calculation_category
    end

    competition[:events]&.each do |event|
      calculation_event = Calculations::V3::Event.new(event: Event.find(event[:id]), multiplier: event[:multiplier])
      calculation.calculations_events << calculation_event
    end
  end
end

def create_calculation(event_id, rules, name)
  puts "create_calculation #{name}"
  if rules[:discipline]
    rules[:discipline] = Discipline.where(name: rules[:discipline]).first!
  end
  if rules[:disciplines]
    rules[:disciplines] = Discipline.where(name: rules[:disciplines])
  end

  rules[:year] = 2018

  if event_id
    event = Event.find(event_id)
    event.calculations.create!(rules)
  else
    Calculations::V3::Calculation.create!(rules)
  end
end

def calculations(competitions)
  Calculations::V3::Calculation.where(key: competitions.keys).all
end

def compare_results(competitions)
  competitions.each do |key, competition|
    next unless competition[:competition_id]

    expected_event = Event.find(competition[:competition_id])
    actual_event = Calculations::V3::Calculation.where(key: key).first&.event

    if actual_event
      unless key.in? %i[age_graded_bar overall_bar]
        compare_source_events(expected_event, actual_event, competition, key)
      end
      # compare_event_results expected_event, actual_event
    else
      puts "Could not find #{key}"
    end
  end
end

def compare_source_events(expected_event, actual_event, competition, key)
  scores = Competitions::Score
           .joins(competition_result: :event)
           .where("results.event_id" => expected_event)
           .where("scores.points > 0")
           .pluck(:source_result_id)

  event_ids = Result.find(scores).pluck(:event_id)
  competition[:do_no_expect]&.each { |e| event_ids.delete(e) }
  competition[:expect]&.each { |e| event_ids << e }

  event_ids = expect_new_calculations(key, event_ids)

  expected = Event.find(event_ids).uniq.sort_by(&:id)
  sources = ResultSource
            .joins(calculated_result: :event)
            .where("results.event_id" => actual_event)
            .where("result_sources.points > 0")
            .pluck(:source_result_id)

  event_ids = Result.find(sources).pluck(:event_id)
  actual = Event.find(event_ids).uniq.sort_by(&:id)
  return if expected == actual

  puts
  puts "#{actual_event.full_name} #{actual_event.id} source events"
  puts "expected: #{expected.map(&:id)}"
  puts "expected: #{expected.map(&:name)}"
  puts "actual:   #{actual.map(&:id)}"
  puts "actual:   #{actual.map(&:name)}"

  missing = expected - actual
  if missing.any?
    puts "missing:"
    missing.each { |event| puts("#{event.id} #{event.date} #{event.full_name}") }
  end

  extra = actual - expected
  if extra.any?
    puts "extra:"
    extra.each { |event| puts("#{event.id} #{event.date} #{event.full_name}") }
  end
end

def expect_new_calculations(key, event_ids)
  tabor = Calculations::V3::Calculation.where(key: :tabor).first&.event
  if key == :road_bar && tabor
    event_ids << tabor.id
  end

  if key == :cyclocross_bar
    %w[blind_date cross_crusade gpcd].each do |other_calc_key|
      event = Calculations::V3::Calculation.where(key: other_calc_key).first&.event
      if event
        event_ids << event.id
      end
    end
  end

  if key == :cross_crusade_team_competition
    cross_crusade_team_competition = Calculations::V3::Calculation.where(key: :cross_crusade_team_competition).first&.event
    if cross_crusade_team_competition
      event_ids << cross_crusade_team_competition.id
    end
  end

  event_ids
end

def compare_event_results(expected_event, actual_event)
  expected_races = expected_event.races.sort
  actual_races = actual_event.races.reject(&:rejected?).select(&:visible?).sort

  expected_categories = expected_races.map(&:name).sort
  actual_categories = actual_races.map(&:name).sort

  if expected_categories != actual_categories
    puts
    puts "#{actual_event.full_name} races"
    puts "expected: #{expected_categories}"
    puts "actual:   #{actual_categories}"

    missing = expected_categories - actual_categories
    if missing.any?
      puts "missing:  #{missing.map(&:name)}"
    end

    extra = actual_categories - expected_categories
    if extra.any?
      puts "extra:    #{extra.map(&:name)}"
    end
  end

  compare_races expected_races, actual_races
end

def compare_races(expected_races, actual_races)
  expected_races.each do |expected_race|
    actual_race = actual_races.detect { |r| r.name == expected_race.name }
    next unless actual_race

    # GPCD Elite Juniors accidentally skipped in 2018
    next if expected_race.id == 614_969 || expected_race.id == 614_970

    expected_results = expected_race.results.reject { |r| r.points == 0 }.map { |result| [result.place, result.person_id, result.points] }.sort
    actual_results = actual_race.results
                                .reload
                                .reject { |r| r.points == 0 }
                                .reject(&:rejected?)
                                .map { |result| [result.place, result.person_id, result.points] }
                                .sort

    compare_individual_results expected_results, actual_results
  end
end

def compare_individual_results(expected_results, actual_results)
  if expected_results.size != actual_results.size
    puts
    puts "Expected #{actual_race.name} to have #{expected_results.size} results, but has #{actual_results.size} in event #{actual_race.event_id}"
  end

  return if expected_results == actual_results

  puts "#{expected_event.full_name} #{expected_event.id} #{expected_race.name} #{expected_race.id} results in #{actual_race.event_id}  #{actual_race.id}"
  puts "expected:"
  pp expected_results
  puts "actual:"
  pp actual_results
  puts "diff:"
  if expected_results.size > actual_results.size
    pp expected_results - actual_results
  else
    pp actual_results - expected_results
  end
end

# competitions = COMPETITIONS
competitions = {
  gpcd_david_douglas_ages: COMPETITIONS[:gpcd_david_douglas_ages],
  gpcd_het_meer_ages: COMPETITIONS[:gpcd_het_meer_ages],
  gpcd_zaaldercross_ages: COMPETITIONS[:gpcd_zaaldercross_ages],
  gpcd_ninkrossi_ages: COMPETITIONS[:gpcd_ninkrossi_ages],
  gpcd_heiser_farm_ages: COMPETITIONS[:gpcd_heiser_farm_ages]
}

# fetch_data
# recreate_databases
# fix_source_results
destroy_calculations
create_calculations competitions
calculations(competitions).map(&:source_event).compact.each(&:update_date)
calculations(competitions).reject { |c| c.key != "overall_bar" && c.key != "age_graded_bar" && c.key["bar"] }.each(&:calculate!)
compare_results competitions

# rubocop:enable Rails/SkipsModelValidations
